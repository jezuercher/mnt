<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of sample_feasible_mu</title>
  <meta name="keywords" content="sample_feasible_mu">
  <meta name="description" content="[mu, success_flag] = sample_feasible_mu(N,ind_ext,v,constraints,options,method,n_sample)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">mnt</a> &gt; <a href="../index.html">mnt_fluxes</a> &gt; <a href="index.html">flux_sampling</a> &gt; sample_feasible_mu.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for mnt/mnt_fluxes/flux_sampling&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>sample_feasible_mu
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>[mu, success_flag] = sample_feasible_mu(N,ind_ext,v,constraints,options,method,n_sample)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [mu, success_flag] = sample_feasible_mu(N,ind_ext,v,constraints,options,method,n_sample) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> [mu, success_flag] = sample_feasible_mu(N,ind_ext,v,constraints,options,method,n_sample)

 Compute (this is no actual sampling!) a number of mu vectors that agree with a given flux vector v

 Compute delta_mu vectors at the boundaries of the feasible region
 set by the (previously sampled or determined) flux directions 
 compute the corresponding mu vectors using the pseudoinverse of N'
 method: 'extreme_points': compute all extreme dmu vectors, covert back to mu vectors
 method: 'sample':         sample n_sample dmu vectors, covert back to mu vectors
 method: 'centre':         central dmu vector, covert back to mu vector</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../mnt/mnt_numbers/RT.html" class="code" title="function result = RT(temperature)">RT</a>	result = RT(temperature)</li><li><a href="../../../mnt/utils/convex_sampling.html" class="code" title="function [x, x_lower, x_upper, success_flag, x_lower_list, x_upper_list] = convex_sampling(A_ineq,b_ineq,A_eq,b_eq,n_sample,xl,xu,verbose,method,options)">convex_sampling</a>	[x, x_lower. x_upper, success_flag, x_lower_list, x_upper_list] = convex_sampling(A_ineq,b_ineq,A_eq,b_eq,n_sample,xl,xu);</li><li><a href="../../../mnt/utils/default.html" class="code" title="function commandstring = default(varargin)">default</a>	commandstring = default(varname1,defaultvalue1,varname2,defaultvalue2,...)</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [mu, success_flag] = sample_feasible_mu(N,ind_ext,v,constraints,options,method,n_sample)</a>
0002 
0003 <span class="comment">% [mu, success_flag] = sample_feasible_mu(N,ind_ext,v,constraints,options,method,n_sample)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Compute (this is no actual sampling!) a number of mu vectors that agree with a given flux vector v</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Compute delta_mu vectors at the boundaries of the feasible region</span>
0008 <span class="comment">% set by the (previously sampled or determined) flux directions</span>
0009 <span class="comment">% compute the corresponding mu vectors using the pseudoinverse of N'</span>
0010 <span class="comment">% method: 'extreme_points': compute all extreme dmu vectors, covert back to mu vectors</span>
0011 <span class="comment">% method: 'sample':         sample n_sample dmu vectors, covert back to mu vectors</span>
0012 <span class="comment">% method: 'centre':         central dmu vector, covert back to mu vector</span>
0013 
0014 eval(<a href="../../../mnt/utils/default.html" class="code" title="function commandstring = default(varargin)">default</a>(<span class="string">'method'</span>,<span class="string">'''extreme_points'''</span>,<span class="string">'n_sample'</span>,<span class="string">'1'</span>,<span class="string">'options'</span>,<span class="string">'struct'</span>));
0015 
0016 mu           = []; 
0017 success_flag = 1;
0018 
0019 [nm,nr] = size(N);
0020 
0021 <span class="keyword">if</span> ~isfield(options,<span class="string">'verbose'</span>),         options.verbose = 0; <span class="keyword">end</span>
0022 <span class="keyword">if</span> ~isfield(options,<span class="string">'seed'</span>),            options.seed = 0; <span class="keyword">end</span>
0023 <span class="keyword">if</span> ~isnan(options.seed), randn(<span class="string">'state'</span>, options.seed); <span class="keyword">end</span>
0024 
0025 <span class="comment">% compute minimal bounding box for reduced chemical potentials</span>
0026 <span class="comment">% U consists of the linearly independent columns of N'</span>
0027 <span class="comment">% represent delta_mu as U * mured</span>
0028 <span class="comment">% represent       N = D * U'</span>
0029 
0030 [ech,ind] = rref(N);
0031 U         = ech(1:length(ind),:)';
0032 n_mured   = size(U,2);
0033 D         = round(N * pinv(full(U')));
0034 
0035 <span class="comment">% WORKAROUND</span>
0036 constraints.mured_min = mean(constraints.mu_min)*ones(n_mured,1);
0037 constraints.mured_max = mean(constraints.mu_max)*ones(n_mured,1);
0038 
0039 dmu_limit      = constraints.dmu_limit - 10^-5; <span class="comment">% be a little stricter</span>
0040 dmu_limit_min  = constraints.dmu_limit_min + 10^-5; <span class="comment">% be a little stricter</span>
0041 
0042 constraints.dmu_min(constraints.dmu_min&lt;-dmu_limit) = -dmu_limit;
0043 constraints.dmu_max(constraints.dmu_max&gt; dmu_limit) =  dmu_limit;
0044 
0045 constraints.dmu_max(find(double([v&gt;0]).*double([constraints.dmu_max&gt;-dmu_limit_min]))) = -dmu_limit_min;
0046 constraints.dmu_min(find(double([v&lt;0]).*double([constraints.dmu_min&lt; dmu_limit_min]))) =  dmu_limit_min;
0047 
0048 ind_dmu_fix = find(isfinite(constraints.dmu_fix));
0049 
0050 <span class="keyword">if</span> ind_dmu_fix,
0051  display(<span class="string">'Using fixed dmu values'</span>),
0052  constraints.dmu_max(ind_dmu_fix) = constraints.dmu_fix(ind_dmu_fix);
0053  constraints.dmu_min(ind_dmu_fix) = constraints.dmu_fix(ind_dmu_fix);
0054 <span class="keyword">end</span>
0055 
0056 epsilon     = <a href="../../../mnt/mnt_numbers/RT.html" class="code" title="function result = RT(temperature)">RT</a>/constraints.rho;
0057 v_signs     = sign(v);
0058 ind_nonzero = find(v_signs~=0);
0059 v_sign_U    = diag(v_signs) * U;
0060 v_sign_U    = v_sign_U(ind_nonzero,:);
0061 
0062 A =  [- eye(n_mured); eye(n_mured); <span class="keyword">...</span>
0063      [- eye(nr); eye(nr) ] * U;
0064         v_sign_U]; 
0065 
0066 b = [- constraints.mured_min; constraints.mured_max;
0067      - constraints.dmu_min;   constraints.dmu_max;<span class="keyword">...</span>
0068      - epsilon*ones(length(ind_nonzero),1)];
0069 
0070 <span class="comment">% avoid inf values in linprog</span>
0071 b(isinf(b))= sign(b(isinf(b))) * 10^10;
0072 
0073 <span class="keyword">switch</span> method, 
0074   
0075   <span class="keyword">case</span> <span class="string">'extreme_points'</span>,
0076 
0077     <span class="comment">%% optimise: vec * mured = min while A * mured &lt;= b</span>
0078     <span class="comment">%%</span>
0079     <span class="comment">%% that is, in detail:</span>
0080     <span class="comment">%% - mured             &lt;= mured_min   i.e.  mured &gt;= mured_min</span>
0081     <span class="comment">%%   mured             &lt;= mured_max   i.e.  mured &lt;= mured_miax</span>
0082     <span class="comment">%% - U mured           &lt;= dmu_min     i.e.  dmu   &gt;= dmu_min</span>
0083     <span class="comment">%%   U mured           &lt;= dmu_max     i.e.  dmu   &lt;= dmu_max</span>
0084     <span class="comment">%%  dg(v_sign)*U*mured &lt;= -epsilon    i.e.  sign(v) * dmu &lt; epsilon &lt;= 0</span>
0085     
0086     <span class="keyword">for</span> it = 1:n_mured,
0087       <span class="keyword">if</span> options.verbose, display(sprintf(<span class="string">'Dimension %d/%d'</span>,it,n_mured)); <span class="keyword">end</span>
0088       vec = zeros(n_mured,1); vec(it) = 1;
0089       opt = optimset(<span class="string">'Display'</span>,<span class="string">'off'</span>); 
0090       [mured_lower_opt,fval,exitflag] = linprog(vec, A, b, [],[],[],[],[],opt);
0091       <span class="keyword">if</span> exitflag &lt;=0, exitflag
0092         error(<span class="string">'Error during linear programming problem for finding feasible chemical potentials'</span>); <span class="keyword">end</span> 
0093       [mured_upper_opt,fval,exitflag] = linprog(-vec, A, b, [],[],[],[],[],opt);
0094       <span class="keyword">if</span> exitflag &lt;=0, exitflag
0095         error(<span class="string">'Error during linear programming problem for finding feasible chemical potentials'</span>); <span class="keyword">end</span> 
0096       dmu_lower(:,it) = U * mured_lower_opt;
0097       dmu_upper(:,it) = U * mured_upper_opt;
0098     <span class="keyword">end</span>
0099 
0100     all_dmu = [dmu_lower, dmu_upper];
0101 
0102    <span class="keyword">case</span> <span class="string">'central'</span>,
0103     all_dmu = find_polytope_centre([],[],A,b);
0104     
0105    <span class="keyword">case</span> <span class="string">'sample'</span>,
0106      all_dmu = <a href="../../../mnt/utils/convex_sampling.html" class="code" title="function [x, x_lower, x_upper, success_flag, x_lower_list, x_upper_list] = convex_sampling(A_ineq,b_ineq,A_eq,b_eq,n_sample,xl,xu,verbose,method,options)">convex_sampling</a>(A,b,[],[],1);
0107 
0108 <span class="keyword">end</span>
0109 
0110 <span class="comment">%mu = pinv(full(N')) * all_dmu;</span>
0111 mu = pinv(full(N')) * U * all_dmu;</pre></div>
<hr><address>Generated on Wed 10-Apr-2013 10:42:33 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>