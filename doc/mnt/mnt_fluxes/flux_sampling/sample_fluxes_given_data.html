<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of sample_fluxes_given_data</title>
  <meta name="keywords" content="sample_fluxes_given_data">
  <meta name="description" content="[sample_v, best_v, C] = sample_fluxes_given_data(N, ind_ext, v_mean, v_std, n_sample_v, n_recombine_v, seed, ind_ignore, v_sign);">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">mnt</a> &gt; <a href="../index.html">mnt_fluxes</a> &gt; <a href="index.html">flux_sampling</a> &gt; sample_fluxes_given_data.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for mnt/mnt_fluxes/flux_sampling&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>sample_fluxes_given_data
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>[sample_v, best_v, C] = sample_fluxes_given_data(N, ind_ext, v_mean, v_std, n_sample_v, n_recombine_v, seed, ind_ignore, v_sign);</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [sample_v, best_v, C] = sample_fluxes_given_data(N,ind_ext,v_mean,v_std,n_sample_v,n_recombine_v,seed,ind_ignore,v_sign); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> [sample_v, best_v, C] = sample_fluxes_given_data(N, ind_ext, v_mean, v_std, n_sample_v, n_recombine_v, seed, ind_ignore, v_sign);

 Sample fluxes (free of thermodyn. cycles) close to data 
  - sample stationary, flux patterns (v = K * rho) resembling given flux data 
     (matrix, several states)
  - select the thermodynamically feasible ones
  - recombine samples for different states, resulting in n_recombine_v sampled matrices
 The first sample is supposed to be the central one</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../mnt/mnt_fluxes/eba/eba_util/eba_beard/cycles.html" class="code" title="function C = cycles(N);">cycles</a>	C = cycles(N);</li><li><a href="../../../mnt/mnt_fluxes/flux_feasibility/eba_feasible.html" class="code" title="function [feasible,C,ind_non_orthogonal] = eba_feasible(v,N,C,ind_ignore,eba_condition,cycle_method)">eba_feasible</a>	[feasible,C,ind_non_orthogonal] = eba_feasible(v,N,C,ind_ignore,eba_condition,cycle_method)</li><li><a href="../../../mnt/utils/default.html" class="code" title="function commandstring = default(varargin)">default</a>	commandstring = default(varname1,defaultvalue1,varname2,defaultvalue2,...)</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [sample_v, best_v, C] = sample_fluxes_given_data(N,ind_ext,v_mean,v_std,n_sample_v,n_recombine_v,seed,ind_ignore,v_sign);</a>
0002 
0003 <span class="comment">% [sample_v, best_v, C] = sample_fluxes_given_data(N, ind_ext, v_mean, v_std, n_sample_v, n_recombine_v, seed, ind_ignore, v_sign);</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Sample fluxes (free of thermodyn. cycles) close to data</span>
0006 <span class="comment">%  - sample stationary, flux patterns (v = K * rho) resembling given flux data</span>
0007 <span class="comment">%     (matrix, several states)</span>
0008 <span class="comment">%  - select the thermodynamically feasible ones</span>
0009 <span class="comment">%  - recombine samples for different states, resulting in n_recombine_v sampled matrices</span>
0010 <span class="comment">% The first sample is supposed to be the central one</span>
0011 
0012 <span class="keyword">if</span> exist(<span class="string">'seed'</span>,<span class="string">'var'</span>), randn(<span class="string">'state'</span>,seed); <span class="keyword">end</span> 
0013 
0014 eval(<a href="../../../mnt/utils/default.html" class="code" title="function commandstring = default(varargin)">default</a>(<span class="string">'ind_ignore'</span>,<span class="string">'[]'</span>));
0015 
0016 ind_missing_std        = find(isfinite(v_mean) .*(1-isfinite(v_std)));
0017 v_std(ind_missing_std) = nanmean(nanmean(v_std)');
0018 
0019 <span class="comment">% replace unknown flux data by broad distribution around 0</span>
0020 <span class="comment">% to prevent unrealisitically high estimates for non-measured fluxes</span>
0021 
0022 v_std(isnan(v_mean))  = 5 * nanstd(v_mean(:));
0023 v_mean(isnan(v_mean)) = 0;
0024 
0025 <span class="comment">% make sure that reference fluxes respect zero flux and sign constraints</span>
0026 
0027 v_mean(v_sign == 0 ) = 0;
0028 v_std( v_sign == 0 ) = 0.01 * nanstd(v_mean(:));
0029 v_std( find(v_mean.*v_sign)&lt;0) = nan;
0030 v_mean(find(v_mean.*v_sign)&lt;0) = nan;
0031 
0032 <span class="comment">% use non-integer rep. of K (safer than analyse_N)</span>
0033 internal = ones(size(N,1),1); 
0034 internal(ind_ext) = 0;
0035 ind_int = find(internal);
0036 Nint    = N(ind_int,:);
0037 K       = null(full(Nint));
0038 
0039 n_modes = size(K,2);
0040 n_exp   = size(v_mean,2);
0041 
0042 <span class="comment">% compute EBA cycles</span>
0043 
0044 <span class="keyword">if</span> ~exist(<span class="string">'C'</span>,<span class="string">'var'</span>),
0045   <span class="keyword">if</span> length(ind_ignore),
0046     use_in_cycles = setdiff(1:size(N,2),ind_ignore);
0047     NN = N(:,use_in_cycles);
0048     CC = <a href="../../../mnt/mnt_fluxes/eba/eba_util/eba_beard/cycles.html" class="code" title="function C = cycles(N);">cycles</a>(NN);
0049     C  = zeros(size(N,2),size(CC,2));
0050     C(use_in_cycles,:) = CC;
0051   <span class="keyword">else</span>
0052     C = <a href="../../../mnt/mnt_fluxes/eba/eba_util/eba_beard/cycles.html" class="code" title="function C = cycles(N);">cycles</a>(N);
0053   <span class="keyword">end</span>
0054 <span class="keyword">end</span>
0055 
0056 <span class="comment">% draw from likelihood corresponding to sum (K*rho - v )^2 /v_std^2</span>
0057 <span class="comment">% and check for thermodynamic feasibility</span>
0058 
0059 <span class="keyword">for</span> it = 1:n_exp;
0060   
0061   display(sprintf(<span class="string">' Biological sample %d / %d'</span>,it,n_exp));
0062 
0063   ind_finite       = find(isfinite(v_mean(:,it)));
0064   v_cov_inv        = diag(1./v_std(ind_finite,it).^2);
0065   rho_cov_inv      = K(ind_finite,:)' * v_cov_inv * K(ind_finite,:);
0066 
0067 <span class="comment">%  safety measure to prevent unrealistic estimates of non-measured fluxes:</span>
0068   rho_cov_inv      = rho_cov_inv + 10^-5 * max(eig(rho_cov_inv)) * eye(size(K,2));
0069 
0070 <span class="comment">% ignore sign constraints</span>
0071 <span class="comment">%  rho_mean         = rho_cov_inv \ [ K(ind_finite,:)' * v_cov_inv * v_mean(ind_finite,it) ];</span>
0072 
0073   epsilon = 10^-10;
0074 <span class="comment">% respect sign constraints</span>
0075   y_mean   = K(ind_finite,:)' * v_cov_inv * v_mean(ind_finite,it);
0076   ind_signs = find(abs(v_sign(:,it))==1);
0077   ind_zeros = find(v_sign(:,it)==0);
0078   A = -diag(v_sign(ind_signs,it)) * K(ind_signs,:);
0079   b = -epsilon * ones(length(ind_signs),1);
0080   Aeq = K(ind_zeros,:);
0081   beq = zeros(length(ind_zeros),1);
0082   warning off all
0083   rho_mean = quadprog(rho_cov_inv,-y_mean,A,b,Aeq,beq);
0084   warning on all
0085   <span class="comment">% try fluxes arising from rho_mean</span>
0086   
0087   fprintf(<span class="string">'  Central sample'</span>);
0088   v_sample{1}(:,it) = K * rho_mean;
0089 <span class="comment">%  figure(1); netgraph_concentrations(network_CoHid,[], v_sample{1}(:,it));</span>
0090   feasible = <a href="../../../mnt/mnt_fluxes/flux_feasibility/eba_feasible.html" class="code" title="function [feasible,C,ind_non_orthogonal] = eba_feasible(v,N,C,ind_ignore,eba_condition,cycle_method)">eba_feasible</a>(v_sample{1}(:,it),N,C);
0091   <span class="keyword">if</span> find( v_sample{1}(ind_signs,it) .* v_sign(ind_signs,it) &lt; 0 ), feasible = 0; fprintf(<span class="string">' .'</span>); <span class="keyword">end</span>
0092   <span class="keyword">if</span> find( abs( v_sample{1}(ind_zeros,it) ) &gt; epsilon ),            feasible = 0; fprintf(<span class="string">' |'</span>); <span class="keyword">end</span>
0093   
0094   <span class="keyword">if</span> ~feasible, fprintf(<span class="string">' unfeasible\n'</span>); <span class="keyword">else</span> fprintf(<span class="string">' feasible\n'</span>);  <span class="keyword">end</span>
0095 <span class="comment">% if the flux distribution is feasible, it is kept as sample No. 1; otherwise, it is replaced</span>
0096   
0097 <span class="comment">% sample other fluxes arising from rho_mean</span>
0098   <span class="keyword">for</span> it_sample = (1+feasible):n_sample_v,
0099     fprintf(<span class="string">'  Random sample %d / %d '</span>,it_sample,n_sample_v);
0100     feasible = 0;
0101     <span class="keyword">while</span> ~feasible,
0102       rho_sample = rho_mean + sqrtm(inv(rho_cov_inv)) * randn(n_modes,1);
0103       v_sample{it_sample}(:,it) = K * rho_sample;
0104       feasible = <a href="../../../mnt/mnt_fluxes/flux_feasibility/eba_feasible.html" class="code" title="function [feasible,C,ind_non_orthogonal] = eba_feasible(v,N,C,ind_ignore,eba_condition,cycle_method)">eba_feasible</a>(v_sample{it_sample}(:,it),N,C);
0105       <span class="keyword">if</span> ~feasible, fprintf(<span class="string">'.'</span>); <span class="keyword">else</span>
0106         <span class="keyword">if</span> find( v_sample{it_sample}(ind_signs,it) .* v_sign(ind_signs,it) &lt; 0 ), feasible = 0; <span class="keyword">end</span>
0107 <span class="comment">% zero values not required for sampled fluxes</span>
0108 <span class="comment">%        if find( abs( v_sample{it_sample}(ind_zeros,it) ) &gt; epsilon ), feasible = 0; end</span>
0109         <span class="keyword">if</span> ~feasible, fprintf(<span class="string">'|'</span>); <span class="keyword">end</span>
0110       <span class="keyword">end</span>
0111     <span class="keyword">end</span>
0112     fprintf(<span class="string">'\n'</span>);
0113   <span class="keyword">end</span>
0114 <span class="keyword">end</span>
0115 
0116 
0117 <span class="comment">% ------------------------------------------------------------------------</span>
0118 <span class="comment">% create many combinations of the random samples</span>
0119 
0120 <span class="keyword">if</span> (n_exp&gt;1) &amp; (exist(<span class="string">'n_recombine_v'</span>,<span class="string">'var'</span>)),
0121   display(sprintf(<span class="string">'\nChoosing %d combinations of the sampled flux patterns'</span>, n_recombine_v));
0122   <span class="keyword">for</span> it_rec = 1:10*n_recombine_v,
0123     <span class="keyword">for</span> it_exp = 1:n_exp,
0124       v_rec{it_rec}(:,it_exp) = v_sample{ceil(n_sample_v*rand)}(:,it_exp);
0125     <span class="keyword">end</span>
0126   <span class="keyword">end</span>
0127   v_sample = v_rec;
0128 <span class="keyword">end</span>
0129 
0130 <span class="keyword">for</span> it = 1:length(v_sample),
0131   v_score(it) = 0;
0132   <span class="keyword">for</span> it_exp = 1:n_exp,
0133     ind_f  = find(isfinite(v_mean(:,it_exp)));
0134     v_score(it) = v_score(it) + sum( ( ( v_mean(ind_f,it_exp) - v_sample{it}(ind_f,it_exp) )./v_std(ind_f,it_exp) ).^2); 
0135   <span class="keyword">end</span>
0136 <span class="keyword">end</span>
0137 
0138 sample_v.v         = v_sample;
0139 sample_v.v_score   = v_score;
0140 
0141 [best_v_score,ind] = min(v_score);
0142 best_v.v           = v_sample{ind};
0143 best_v.v_score     = best_v_score;</pre></div>
<hr><address>Generated on Wed 10-Apr-2013 10:42:33 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>