function quantity_table = modular_rate_law_to_sbtab(network,filename,options)

% quantity_table = modular_rate_law_to_sbtab(network,filename,options)
% 
% Requires the SBtab toolbox

eval(default('options','struct','filename','[]'));

options_default = struct('use_sbml_ids',1,'write_individual_kcat',1,'write_concentrations',1);
options         = join_struct(options_default,options);

switch network.kinetics.type
  case {'cs','ms','rp','ma','fm'}, % UPDATE rate law names!
  otherwise, error('Conversion is only possible for modular rate law');
end

[nm,nr] = size(network.N);

if options.use_sbml_ids, 
  metabolites = network.sbml_id_species; 
  reactions   = network.sbml_id_reaction; 
else
  metabolites = network.metabolites; 
  reactions   = network.actions; 
  [metabolites,reactions] = network_adjust_names_for_sbml_export(metabolites,reactions);
end

if isfield(network, 'metabolite_KEGGID'),
  metabolite_KEGGID = network.metabolite_KEGGID; 
else
  metabolite_KEGGID = repmat({''},nm,1);
end

if isfield(network, 'reaction_KEGGID'),
  reaction_KEGGID = network.reaction_KEGGID; 
else
  reaction_KEGGID = repmat({''},nr,1);
end

[nr,nm,nx,KM_indices,KA_indices,KI_indices,nKM,nKA,nKI] = network_numbers(network);


column_quantity = [ repmat({'equilibrium constant'},nr,1); ...
                    repmat({'catalytic rate constant geometric mean'},nr,1); ...
                    repmat({'Michaelis constant'},nKM,1); ...
                    repmat({'activation constant'},nKA,1); ...
                    repmat({'inhibitory constant'},nKI,1); ...
                   ];

column_value = full( [ network.kinetics.Keq; ...
                network.kinetics.KV; ...
                network.kinetics.KM(KM_indices); ...
                network.kinetics.KA(KA_indices); ...
                network.kinetics.KI(KI_indices); ...
              ]);

column_unit = [ repmat({'-'},nr,1); ...
                    repmat({'1/s'},nr,1); ...
                    repmat({'mM'},nKM,1); ...
                    repmat({'mM'},nKA,1); ...
                    repmat({'mM'},nKI,1); ...
                   ];    

[iKM,jKM] = ind2sub([nr,nm],KM_indices);
[iKA,jKA] = ind2sub([nr,nm],KA_indices);
[iKI,jKI] = ind2sub([nr,nm],KI_indices);

column_reaction = [ reactions; ...
                    reactions; ...
                    reactions(iKM); ...
                    reactions(iKA); ...
                    reactions(iKI); ...
                   ];    

column_reaction_KEGGID = [ reaction_KEGGID; ...
                    reaction_KEGGID; ...
                    reaction_KEGGID(iKM); ...
                    reaction_KEGGID(iKA); ...
                    reaction_KEGGID(iKI); ...
                   ];    

column_compound = [ repmat({''},nr,1); ...
                    repmat({''},nr,1); ...
                    metabolites(jKM); ...
                    metabolites(jKA); ...
                    metabolites(jKI); ...
                  ];

column_compound_KEGGID = [ repmat({''},nm,1); ...
                    repmat({''},nr,1); ...
                    metabolite_KEGGID(jKM); ...
                    metabolite_KEGGID(jKA); ...
                    metabolite_KEGGID(jKI); ...
                  ];

% Only if required: write individual kcat values

if ~isfield(network.kinetics,'Kcatf'),
  options.write_individual_kcat = 0;
end

if options.write_individual_kcat,

column_quantity = [ column_quantity; ...
                    repmat({'substrate catalytic rate constant'},nr,1); ...
                    repmat({'product catalytic rate constant'},nr,1); ...
                  ];

column_value = [ column_value; ...
                 network.kinetics.Kcatf; ...
                 network.kinetics.Kcatr; ...
               ];

column_unit = [ column_unit; ...
                repmat({'1/s'},nr,1); ...
                repmat({'1/s'},nr,1); ...
              ];    

column_reaction = [ column_reaction; ...
                    reactions; ...
                    reactions; ...
                   ];    

column_compound = [ column_compound; ...
                    repmat({''},nr,1); ...
                    repmat({''},nr,1); ...
                  ];

column_reaction_KEGGID = [ column_reaction_KEGGID; ...
                    reaction_KEGGID; ...
                    reaction_KEGGID; ...
                   ];    

column_compound_KEGGID = [ column_compound_KEGGID; ...
                    repmat({''},nr,1); ...
                    repmat({''},nr,1); ...
                  ];
  
end


% Only if required: write metabolite and enzyme concentrations


if options.write_concentrations,

column_quantity = [ column_quantity; ...
                    repmat({'concentration'},nm,1); ...
                    repmat({'concentration of enzyme'},nr,1); ...
                   ];

column_value =  [ column_value; ...
                network.kinetics.c ; ...
                network.kinetics.u; ...
              ];

column_unit = [ column_unit; ...
                    repmat({'mM'},nm,1); ...
                    repmat({'mM'},nr,1); ...
                   ];    

column_reaction = [ column_reaction; ...
                    repmat({''},nm,1); ...
                    reactions; ...
                   ];    

column_compound = [ column_compound; ...
                    metabolites; ...
                    repmat({''},nr,1); ...
                  ];

column_reaction_KEGGID = [ column_reaction_KEGGID; ...
                    repmat({''},nm,1); ...
                    reaction_KEGGID; ...
                   ];    

column_compound_KEGGID = [ column_compound_KEGGID; ...
                    metabolite_KEGGID; ...
                    repmat({''},nr,1); ...
                  ];

end

quantity_table = sbtab_table_construct(struct('TableName','RateConstant','TableType','Quantity'), {'QuantityType','Value','Compound','Compound:Identifiers:kegg.compound','Reaction','Reaction:Identifiers:kegg.reaction','Unit'}, {column_quantity,column_value,column_compound,column_compound_KEGGID,column_reaction,column_reaction_KEGGID,column_unit});

if length(filename), 
  sbtab_table_save(quantity_table,struct('filename',filename)); 
end
